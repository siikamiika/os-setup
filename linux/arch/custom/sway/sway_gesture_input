#!/usr/bin/env python3

import subprocess
import re
import time
import evdev
from evdev.ecodes import *


# https://stackoverflow.com/a/923034
def set_proc_name(newname):
    from ctypes import cdll, byref, create_string_buffer
    libc = cdll.LoadLibrary('libc.so.6')
    buff = create_string_buffer(len(newname)+1)
    buff.value = newname
    libc.prctl(15, byref(buff), 0, 0, 0)


class LibinputDebugEventReader:

    def get_events(self):
        proc = subprocess.Popen(
            ['unbuffer', 'libinput', 'debug-events'],
            stdout=subprocess.PIPE,
            bufsize=1,
            universal_newlines=True
        )
        for line in proc.stdout:
            parsed_event = self.parse_event(line)
            if parsed_event:
                yield parsed_event

    def parse_event(self, line):
        re_float = '[+-]?\d*\.\d*'
        m = re.match(
            rf'''
            \s*
            event\d+
            \s+
            (?P<type>
                GESTURE_SWIPE_UPDATE|GESTURE_SWIPE_END|POINTER_SCROLL_FINGER
            )
            \s+
            \+\d*\.\d*s
            \s+
            (?:
                (?P<fingers>
                    \d+
                )
                \s*
                (?:
                    $
                    |
                    cancelled
                    |
                    (?P<swipe_x>
                        {re_float}
                    )
                    \/\s?
                    (?P<swipe_y>
                        {re_float}
                    )
                )
                |
                vert\s+
                (?P<scroll_y>
                    {re_float}
                )
                \/.*?
                horiz\s+
                (?P<scroll_x>
                    {re_float}
                )
            )
            ''',
            line,
            re.VERBOSE
        )
        if m:
            event_type = m.group('type')
            if event_type == 'GESTURE_SWIPE_UPDATE':
                return {
                    'type': 'update',
                    'fingers': int(m.group('fingers')),
                    'swipe_x': float(m.group('swipe_x')),
                    'swipe_y': float(m.group('swipe_y')),
                }
            elif event_type == 'GESTURE_SWIPE_END':
                return {
                    'type': 'end',
                    'fingers': int(m.group('fingers')),
                }
            elif event_type == 'POINTER_SCROLL_FINGER':
                scroll_x, scroll_y = map(float, (m.group('scroll_x'), m.group('scroll_y')))
                if scroll_x == scroll_y == 0.0:
                    return {
                        'type': 'end',
                        'fingers': 2,
                    }
                return {
                    'type': 'update',
                    'fingers': 2,
                    'swipe_x': scroll_x,
                    'swipe_y': scroll_y,
                }


class GestureEventSource:

    EVENT_THRESHOLD = 100.0
    RELEASE_THRESHOLD_FACTOR = 0.1

    def __init__(self):
        self._state = {
            'started': None,
            'fingers': None,
            'pos_x': 0.0,
            'pos_y': 0.0,
            'threshold': GestureEventSource.EVENT_THRESHOLD,
            'events_triggered':  0,
        }
        self._event_reader = LibinputDebugEventReader()

    def listen(self):
        for event in self._event_reader.get_events():
            # TODO check if fingers is the same
            if event['type'] == 'update':
                if self._state['started'] is None:
                    self._state['started'] = time.time()
                    self._state['fingers'] = event['fingers']
                self._state['pos_x'] += event['swipe_x']
                self._state['pos_y'] += event['swipe_y']
                yield from self._consume()
            elif event['type'] == 'end':
                if self._state['events_triggered'] == 0:
                    self._state['threshold'] *= GestureEventSource.RELEASE_THRESHOLD_FACTOR
                    yield from self._consume(max_events=1)
                self._reset_state()

    def _consume(self, max_events=None):
        other_axis, consumed_axis = sorted(['pos_x', 'pos_y'], key=lambda a: abs(self._state[a]))
        self._state[other_axis] = 0.0
        while True:
            if self._state[consumed_axis] >= self._state['threshold']:
                self._state[consumed_axis] -= self._state['threshold']
                self._state['events_triggered'] += 1
                direction = 'right' if consumed_axis == 'pos_x' else 'down'
                yield {
                    'direction': direction,
                    'fingers': self._state['fingers'],
                    'single': max_events is not None,
                }
            elif self._state[consumed_axis] <= -self._state['threshold']:
                self._state[consumed_axis] += self._state['threshold']
                self._state['events_triggered'] += 1
                direction = 'left' if consumed_axis == 'pos_x' else 'up'
                yield {
                    'direction': direction,
                    'fingers': self._state['fingers'],
                    'single': max_events is not None,
                }
            else:
                break
            if max_events is not None:
                if max_events >= self._state['events_triggered']:
                    break

    def _reset_state(self):
        self._state['fingers'] = None
        self._state['started'] = None
        self._state['pos_x'] = 0.0
        self._state['pos_y'] = 0.0
        self._state['threshold'] = GestureEventSource.EVENT_THRESHOLD
        self._state['events_triggered'] = 0


class Sway:
    def get_focused_app(self):
        p = subprocess.run(
            "swaymsg -t get_tree | jq -r '.. | .nodes? | .[]? | select(.focused == true) | .app_id'",
            stdout=subprocess.PIPE,
            shell=True
        )
        return p.stdout.decode('utf-8').strip()

    def change_focus(self, direction):
        if direction in ['left', 'right', 'up', 'down']:
            subprocess.call(['swaymsg', 'focus', direction])

    def change_workspace(self, direction):
        if direction == 'left':
            subprocess.call(['swaymsg', 'workspace', 'prev_on_output'])
        elif direction == 'right':
            subprocess.call(['swaymsg', 'workspace', 'next_on_output'])


def main():
    # single instance hack
    subprocess.call('pgrep -x sgi_hack | head -1 | xargs -r pkill -TERM -P', shell=True)
    set_proc_name(b'sgi_hack')

    mouse = evdev.UInput({
        EV_KEY: [BTN_LEFT, BTN_RIGHT, BTN_MIDDLE, BTN_SIDE, BTN_EXTRA, BTN_FORWARD],
        EV_REL: [REL_X, REL_Y, REL_WHEEL, REL_HWHEEL],
    }, name='sgi-virt-mouse')
    keyboard = evdev.UInput({
        EV_KEY: [KEY_LEFTCTRL, KEY_LEFTSHIFT,
                 KEY_PAGEUP, KEY_PAGEDOWN,
                 KEY_W, KEY_T, KEY_R,
                 KEY_BACK, KEY_FORWARD],
    }, name='sgi-virt-keyboard')
    sway = Sway()
    ges = GestureEventSource()
    for event in ges.listen():
        if event['fingers'] == 2:
            # precise wheel to discrete event for container tab cycling
            if event['direction'] == 'right':
                mouse.write(EV_REL, REL_HWHEEL, 1)
            elif event['direction'] == 'left':
                mouse.write(EV_REL, REL_HWHEEL, -1)
            mouse.syn()
        elif event['fingers'] == 3:
            # overload multi-event/single-event gestures
            if event['single']:
                # browser history
                if event['direction'] == 'left':
                    keyboard.write(EV_KEY, KEY_BACK, 1)
                    keyboard.write(EV_KEY, KEY_BACK, 0)
                    keyboard.syn()
                elif event['direction'] == 'right':
                    keyboard.write(EV_KEY, KEY_FORWARD, 1)
                    keyboard.write(EV_KEY, KEY_FORWARD, 0)
                    keyboard.syn()
                # reopen/close tab
                elif event['direction'] == 'up':
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 1)
                    keyboard.write(EV_KEY, KEY_LEFTSHIFT, 1)
                    keyboard.write(EV_KEY, KEY_T, 1)
                    keyboard.write(EV_KEY, KEY_T, 0)
                    keyboard.write(EV_KEY, KEY_LEFTSHIFT, 0)
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 0)
                    keyboard.syn()
                elif event['direction'] == 'down':
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 1)
                    keyboard.write(EV_KEY, KEY_W, 1)
                    keyboard.write(EV_KEY, KEY_W, 0)
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 0)
                    keyboard.syn()
            else:
                # cycle tabs
                if event['direction'] == 'left':
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 1)
                    keyboard.write(EV_KEY, KEY_PAGEUP, 1)
                    keyboard.write(EV_KEY, KEY_PAGEUP, 0)
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 0)
                    keyboard.syn()
                elif event['direction'] == 'right':
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 1)
                    keyboard.write(EV_KEY, KEY_PAGEDOWN, 1)
                    keyboard.write(EV_KEY, KEY_PAGEDOWN, 0)
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 0)
                    keyboard.syn()
                elif event['direction'] == 'up':
                    pass
                elif event['direction'] == 'down':
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 1)
                    keyboard.write(EV_KEY, KEY_R, 1)
                    keyboard.write(EV_KEY, KEY_R, 0)
                    keyboard.write(EV_KEY, KEY_LEFTCTRL, 0)
                    keyboard.syn()
        elif event['fingers'] == 4:
            if event['direction'] == 'left':
                sway.change_workspace('left')
            elif event['direction'] == 'right':
                sway.change_workspace('right')


if __name__ == '__main__':
    main()
