- https://wiki.archlinux.org/title/WireGuard
- https://gitlab.com/NickCao/RAIT
- https://www.jordanwhited.com/posts/wireguard-endpoint-discovery-nat-traversal/
    - full-cone nat
        - wg show wg0 endpoints
        - if server uses port forwarding, filter out LAN endpoints
    - port/address restricted cone nat
    - symmetric nat
        - forward through server
- https://lists.zx2c4.com/pipermail/wireguard/2017-December/002201.html
- https://notes.superlogical.ch/pages/note_wg/nolayer2/
    - GRE https://developers.redhat.com/blog/2019/05/17/an-introduction-to-linux-virtual-interfaces-tunnels
    - VXLAN
    - L2TP
    - point to site
- obfuscation
    - https://github.com/wangyu-/udp2raw
    - https://github.com/rfc1036/udptunnel
- peer daemon systemd unit
- key rotation
    - wg syncconf wg0 <(wg-quick strip wg0)
- keepalive
    - on demand
- server-client communication
    - https://youtu.be/88GyLoZbDNw?t=568
        - but: net.ipv4.ip_forward
        - also: browser
    - HMAC(PSK, content, sha256)
        - content: {pubkey: <pubkey>, data: <data>, timestamp: 1234.56789}
        - replay attacks
            - 5 sec window, disallow duplicates within that
            - alternative: include previous MAC in content
                - content {
                    pubkey: <pubkey>,
                    data: <data>,
                    timestamp: 1234.5678
                    mac: HMAC(PSK, HMAC(PSK, content(-1), sha256)) | null  // 10 sec timeout
                }
            - edge case: attacker controls NTP
                - monotonic clock
                - /proc/stat btime + time.monotonic()
            - one more alternative https://datatracker.ietf.org/doc/html/draft-ietf-babel-hmac
                - ...
                  In this situation, A discards the packet and challenges B to prove
                  that it knows the MAC key.  It sends a "challenge request", a TLV
                  containing a unique nonce, a value that has never been used before
                  and will never be used again.  B replies to the challenge request
                  with a "challenge reply", a TLV containing a copy of the nonce chosen
                  by A, in a packet protected by MAC and containing the new value of
                  B's PC.  Since the nonce has never been used before, B's reply proves
                  B's knowledge of the MAC key and the freshness of the PC.
                  ...
                  Another mechanism is needed to protect against this attack.  In this
                  protocol, every PC is tagged with an "index", an arbitrary string of
                  octets.  Whenever B resets its PC, or whenever B doesn't know whether
                  its PC has been reset, it picks an index that it has never used
                  before (either by drawing it randomly or by using a reliable hardware
                  clock) and starts sending PCs with that index.  Whenever A detects
                  that B has changed its index, it challenges B again.
        - no additional encryption
- dynamic port
- https://en.wikipedia.org/wiki/OpenID
