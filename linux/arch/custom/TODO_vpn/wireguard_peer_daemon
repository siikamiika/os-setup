#!/usr/bin/env python3

import os
import re
import contextlib
import socketserver
import pwd
import grp
import ipaddress
import subprocess
import json
import sqlite3
import struct
import socket
import traceback
import base64
from typing import Optional, Dict, Any, Iterator


class WireguardUsers:

    _DB_PATH = '/var/local/wireguard_users.db'

    def __init__(self):
        self._con = self._get_db_connection()
        self._cur = self._con.cursor()
        self._ensure_tables()

    def get_public_key(self, uid: int) -> Optional[str]:
        for row in self._execute(
            'SELECT public_key FROM wireguard_users WHERE uid = ?',
            [uid]
        ):
            return row[0]
        return None

    def add_public_key(self, uid: int, public_key: str):
        # Allow the same uid to update their public key but abort when
        # another uid tries to reuse one (see CREATE TABLE)
        self._execute(
            'INSERT INTO wireguard_users (uid, public_key) VALUES (?, ?) '
            'ON CONFLICT(uid) DO UPDATE SET public_key = ?',
            [uid, public_key, public_key]
        )

    def _get_db_connection(self) -> sqlite3.Connection:
        path = WireguardUsers._DB_PATH
        if not os.path.isfile(path):
            # not directly readable or writable for peers
            fd = os.open(path, os.O_CREAT, mode=0o600)
            os.close(fd)
        return sqlite3.connect(path)

    def _ensure_tables(self):
        self._execute('''
            CREATE TABLE IF NOT EXISTS wireguard_users (
                uid INTEGER UNIQUE,
                public_key TEXT UNIQUE ON CONFLICT ABORT
            )
        ''')
        self._execute('CREATE INDEX IF NOT EXISTS uid_idx ON wireguard_users (uid)')
        self._execute('CREATE INDEX IF NOT EXISTS public_key_idx ON wireguard_users (public_key)')

    def _execute(self, sql, params=[]):
        res = self._cur.execute(sql, params)
        self._con.commit()
        return res


class WireguardConfig:
    # TODO write only, use sqlite DB for state
    _FIELD_RE = re.compile(r'^(?P<key>[a-zA-Z]+)\s*=\s*(?P<value>.+)$')

    def __init__(self, path):
        self._path = path
        self._interface = None
        self._peers = {}
        self._parse()

    # interface
    def get_interface(self) -> Dict[str, str]:
        if self._interface is None:
            raise Exception('Config doesn\'t have interface')
        return self._interface['fields']

    def update_interface_fields(self, fields: Dict[str, Optional[str]]):
        if self._interface is None:
            raise Exception('Config doesn\'t have interface')
        for field, value in fields.items():
            if value is None:
                if field in self._interface['fields']:
                    del self._interface['fields'][field]
            else:
                self._interface['fields'][field] = self._validate_interface_field(field, value)

    # peers
    def has_peer(self, public_key: str):
        return public_key in self._peers

    def get_peer(self, public_key: str) -> Dict[str, str]:
        return dict(self._peers[public_key]['fields'])

    def iter_peers(self) -> Iterator[Dict[str, Optional[str]]]:
        for peer in self._peers.values():
            yield peer['fields']

    def update_peer_fields(self, public_key: str, fields: Dict[str, Optional[str]]):
        peer = self._peers.get(public_key)
        if peer is None:
            raise Exception(f'Peer not found for public key {public_key}')
        for field, value in fields.items():
            if value is None:
                if field in peer['fields']:
                    del peer['fields'][field]
            else:
                peer['fields'][field] = self._validate_peer_field(field, value)

    def add_peer(self, public_key: str, fields: Dict[str, Optional[str]]):
        self._peers[public_key] = {
            'type': 'Peer',
            'fields': {k: self._validate_peer_field(k, v) for k, v in fields.items() if v is not None}
        }

    def delete_peer(self, public_key: str):
        if public_key in self._peers:
            del self._peers[public_key]

    # persist
    def save(self):
        if not os.path.isfile(self._path):
            fd = os.open(self._path, os.O_CREAT, mode=0o600)
            os.close(fd)
        block_sources = [self._interface, *self._peers.values()]
        blocks = map(self._construct_block, block_sources)
        content = '\n\n'.join(blocks) + '\n'
        with open(self._path, 'w') as f:
            f.write(content)

    # private
    def _construct_block(self, block: Dict[str, Any]) -> str:
        header = '[' + block['type'] + ']'
        fields = []
        for k, v in block['fields'].items():
            if v:
                fields.append(f'{k} = {v}')
        return '\n'.join([header, *fields])

    def _parse(self):
        if not os.path.isfile(self._path):
            self._interface = {
                'type': 'Interface',
                'fields': {
                    'Address': '10.0.0.1/24',
                    'ListenPort': '51820',
                    'PrivateKey': self._gen_privkey(),
                }
            }
            self.save()
            return
        with open(self._path) as f:
            for block in f.read().split('\n\n'):
                parsed_block = self._parse_block(block)
                if parsed_block['type'] == 'Interface':
                    self._interface = parsed_block
                elif parsed_block['type'] == 'Peer':
                    self._peers[parsed_block['fields']['PublicKey']] = parsed_block
                else:
                    raise Exception(f'Cannot parse block type {parsed_block["type"]}')

    def _parse_block(self, block: str) -> Dict[str, Any]:
        block_data = {
            'type': None,
            'fields': {}
        }
        for line in block.splitlines():
            if not block_data.get('type'):
                if line == '[Interface]':
                    block_data['type'] = 'Interface'
                elif line == '[Peer]':
                    block_data['type'] = 'Peer'
                else:
                    raise Exception(f'Unexpected block header: {line}')
                continue
            m = self._FIELD_RE.match(line)
            if m:
                field = m.groupdict()
                block_data['fields'][field['key']] = field['value']
            else:
                raise Exception(f'Invalid field: {line}')
        return block_data

    def _validate_peer_field(self, field: str, value: str) -> str:
        # TODO handle fields properly
        if field in {'PublicKey', 'PresharedKey'}:
            self._validate_base64(value)
        elif field in {'AllowedIPs', 'Endpoint'}:
            self._validate_linebreak(value)
        else:
            raise Exception(f'Unexpected field: {field}')
        return value

    def _validate_interface_field(self, field: str, value: str) -> str:
        if field == 'Address':
            self._validate_linebreak(value)
        else:
            raise Exception(f'Unexpected field: {field}')
        return value

    def _validate_base64(self, value: str):
        value1 = value.encode('utf-8')
        value2 = base64.b64encode(base64.b64decode(value1))
        if value1 != value2:
            raise Exception(f'Invalid base64 value: {value}')

    def _validate_linebreak(self, value: str):
        if re.search(r'[\r\n]', value):
            raise Exception(f'Value cannot contain line breaks')

    def _gen_privkey(self) -> str:
        key_proc = subprocess.run(['wg', 'genkey'], stdout=subprocess.PIPE)
        if not key_proc.stdout:
            raise Exception('Could not generate key')
        return key_proc.stdout.decode('utf-8').rstrip('\n')


class WireguardLocalUserAuthentication:
    """
    Authenticate a user based on their group membership and add
    public key to the database
    """
    def __init__(self, wireguard_users: WireguardUsers, wireguard_config: WireguardConfig):
        self._wireguard_users = wireguard_users
        self._wireguard_config = wireguard_config

    # TODO handler typing?
    def authenticate(self, handler) -> tuple[int, Optional[Dict]]:
        creds = handler.request.getsockopt(
            socket.SOL_SOCKET,
            socket.SO_PEERCRED,
            struct.calcsize('3i')
        )
        _, uid, _ = struct.unpack('3i', creds)
        user = pwd.getpwuid(uid)
        wireguard_users_group = grp.getgrnam('wireguard_users')
        if uid != 0 and user.pw_name not in wireguard_users_group.gr_mem:
            return uid, None
        command = json.loads(handler.rfile.readline())
        # root user override
        if uid == 0:
            return uid, command
        public_key = command['public_key']
        old_public_key = self._wireguard_users.get_public_key(uid)
        if old_public_key == public_key:
            return uid, command
        elif old_public_key is not None:
            self._wireguard_config.delete_peer(old_public_key)
            self._wireguard_config.save()
        # will fail when trying to reuse a public key
        self._wireguard_users.add_public_key(uid, public_key)
        return uid, command


class WireguardPeerAuthentication:
    """
    Authenticate an existing peer using HMAC
    """
    # def __init__(self, wireguard_config_manager: WireguardConfigManager):
    #     self._wireguard_config_manager = wireguard_config_manager

    # TODO handler typing?
    def authenticate(self, handler) -> Optional[Dict]:
        # TODO correct network interface
        # TODO HMAC
        pass


class WireguardLocalUserServer(socketserver.UnixStreamServer):

    def __init__(self, *args, **kwargs):
        command_handler = kwargs.pop('command_handler')
        authentication = kwargs.pop('authentication')
        super().__init__(*args, **kwargs)
        self.command_handler: WireguardCommandHandler = command_handler
        self.authentication: WireguardLocalUserAuthentication = authentication

    def server_bind(self):
        fd = self.socket.fileno()
        # restrict access to root before binding
        os.fchmod(fd, 0o600)
        super().server_bind()

    def server_activate(self):
        super().server_activate()
        addr = self.server_address
        if not isinstance(addr, str):
            raise Exception(f'Unexpected server_address: {addr}')
        # grant access to the wireguard_users group as well
        root_user = pwd.getpwnam('root')
        wireguard_users_group = grp.getgrnam('wireguard_users')
        os.chown(addr, root_user.pw_uid, wireguard_users_group.gr_gid)
        os.chmod(addr, 0o660)


class WireguardLocalUserRequestHandler(socketserver.StreamRequestHandler):

    server: WireguardLocalUserServer

    def handle(self):
        uid, command = self.server.authentication.authenticate(self)
        if command is not None:
            self._handle_command(command, uid)

    def _handle_command(self, command: Dict[str, Any], uid: int):
        source = 'root_user' if uid == 0 else 'local_user'
        result = self.server.command_handler.handle(command, source)
        self.wfile.write(json.dumps(result).encode('utf-8') + b'\n')


class WireguardCommandHandler:

    def __init__(self, config: WireguardConfig, meta_config: Dict[str, Any]):
        self._config = config
        self._meta_config = meta_config

    def handle(self, command: Dict[str, Any], source: str):
        result: Dict[str, Any] = {
            'status': None,
            'data': None
        }
        try:
            if command['command'] == 'pair' and source in ['local_user', 'root_user']:
                result['data'] = self._handle_pair(command)
            elif command['command'] == 'receive_pair' and source == 'root_user':
                result['data'] = self._handle_receive_pair(command)
            elif command['command'] == 'get_public_key' and source == 'root_user':
                result['data'] = self._handle_get_public_key(command)
            elif command['command'] == 'update_peer_fields' and source in ['local_user', 'root_user']:
                result['data'] = self._handle_update_peer_fields(command)
            else:
                raise Exception(f'Unexpected command: {command["command"]}')
            result['status'] = 'ok'
        except Exception as e:
            result['status'] = 'error'
            # TODO error debug level flag
            result['data'] = ''.join(traceback.TracebackException.from_exception(e).format())
        return result

    # command handlers
    def _handle_pair(self, command: Dict[str, Any]) -> Dict[str, Any]:
        """
        Handle a pairing request by a client assuming that we are the server
        """
        public_key = command['public_key']
        fields = command['data']['fields']

        self._config.delete_peer(public_key)

        new_peer_psk = self._gen_psk()
        new_peer_address = self._get_available_address()

        # add new peer to own config
        self._config.add_peer(public_key, {
            **fields,
            'PublicKey': public_key,
            'PresharedKey': new_peer_psk,
            'AllowedIPs': str(ipaddress.IPv4Network(new_peer_address)),
        })
        self._config.save()
        self._reload_wireguard_config()

        this_interface = self._config.get_interface()
        ip_interface = ipaddress.IPv4Interface(this_interface['Address'])

        interface_conf = {
            'type': 'Interface',
            'fields': {
                'Address': str(ipaddress.IPv4Interface((
                    str(new_peer_address),
                    str(ip_interface.netmask)
                ))),
            }
        }

        peer_conf = {
            'type': 'Peer',
            'fields': {
                'PublicKey': self._get_pubkey(),
                'PresharedKey': new_peer_psk,
                'AllowedIPs': str(ipaddress.IPv4Network(ip_interface.ip)),
                'Endpoint': f'{self._meta_config["endpoint_host"]}:{this_interface["ListenPort"]}',
            }
        }

        # return new peer as interface and interface as peer
        return {
            'interface': interface_conf,
            'peer': peer_conf,
        }

    def _handle_receive_pair(self, command: Dict[str, Any]) -> Dict[str, Any]:
        interface_conf = command['data']['interface']
        peer_conf = command['data']['peer']

        self._config.update_interface_fields(interface_conf['fields'])

        peer_public_key = peer_conf['fields']['PublicKey']
        self._config.add_peer(peer_public_key, peer_conf['fields'])

        self._config.save()
        self._enable_wireguard()

        return {}

    def _handle_get_public_key(self, command: Dict[str, Any]) -> Dict[str, Any]:
        return {'PublicKey': self._get_pubkey()}

    def _handle_update_peer_fields(self, command: Dict[str, Any]) -> Dict[str, str]:
        """
        TODO
        """
        public_key = command['public_key']
        fields = command['data']['fields']

        # TODO case sensitivity?
        for field in ['PublicKey', 'PresharedKey', 'AllowedIPs']:
            if field in fields:
                raise Exception(f'Cannot update field {field}')
        self._config.update_peer_fields(public_key, fields)
        self._config.save()
        return self._config.get_peer(public_key)

    # misc
    def _get_available_address(self) -> ipaddress.IPv4Address:
        interface = self._config.get_interface()
        ip_interface = ipaddress.IPv4Interface(interface['Address'])
        network = ip_interface.network
        reserved = {ip_interface.ip, network.network_address}
        for peer in self._config.iter_peers():
            if 'AllowedIPs' not in peer or peer['AllowedIPs'] is None:
                raise Exception(f'Peer {peer["PublicKey"]} is missing AllowedIPs')
            for peer_network in peer['AllowedIPs'].split(', '):
                peer_network = ipaddress.IPv4Network(peer_network)
                if peer_network.subnet_of(network):
                    reserved |= set(peer_network)
        for ip in network:
            if ip not in reserved:
                return ip
        raise Exception('Address space exhausted')

    def _gen_psk(self) -> str:
        psk_proc = subprocess.run(['wg', 'genpsk'], stdout=subprocess.PIPE)
        if not psk_proc.stdout:
            raise Exception('Could not generate PSK')
        return psk_proc.stdout.decode('utf-8').rstrip('\n')

    def _get_pubkey(self) -> str:
        interface = self._config.get_interface()
        pubkey_proc = subprocess.Popen(
            ['wg', 'pubkey'],
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE
        )
        if not pubkey_proc.stdin:
            raise Exception('Could not generate public key')
        private_key = interface['PrivateKey'] + '\n'
        pubkey_proc.stdin.write(private_key.encode('utf-8'))
        pubkey_proc.stdin.close()
        if not pubkey_proc.stdout:
            raise Exception('Could not generate public key')
        return pubkey_proc.stdout.read().decode('utf-8').rstrip('\n')

    def _enable_wireguard(self):
        subprocess.run(['systemctl', 'enable', '--now', 'wg-quick@wg0'])

    def _reload_wireguard_config(self):
        subprocess.Popen(['wg', 'syncconf', 'wg0', '/etc/wireguard/wg0.conf'])


class WireguardPeerDaemon:
    def __init__(self):
        self._wireguard_users = WireguardUsers()
        self._wireguard_config = WireguardConfig('/etc/wireguard/wg0.conf')
        self._config = self._load_config()
        self._wireguard_command_handler = WireguardCommandHandler(self._wireguard_config, self._config)
        self._local_user_server = self._get_local_user_server()

    def start(self):
        self._local_user_server.serve_forever()
        # TODO TCP

    def _get_local_user_server(self):
        socket_path = '/run/wireguard_peer.sock'
        with contextlib.suppress(FileNotFoundError):
            os.remove(socket_path)
        return WireguardLocalUserServer(
            socket_path,
            WireguardLocalUserRequestHandler,
            command_handler=self._wireguard_command_handler,
            authentication=WireguardLocalUserAuthentication(
                self._wireguard_users,
                self._wireguard_config
            )
        )

    def _load_config(self):
        config = {'endpoint_host': '0.0.0.0'}
        with contextlib.suppress(FileNotFoundError):
            with open('/usr/local/etc/wireguard_peer_daemon.json') as f:
                config.update(json.load(f))
        return config


def main():
    wireguard_peer_daemon = WireguardPeerDaemon()
    wireguard_peer_daemon.start()


if __name__ == '__main__':
    main()
