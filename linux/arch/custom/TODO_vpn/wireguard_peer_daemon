#!/usr/bin/env python3

import os
import re
import contextlib
import socketserver
import pwd
import grp
import ipaddress
import subprocess
import json
import sqlite3
import struct
import socket
import traceback
from typing import Optional, Dict, Any, Iterator


class WireguardUsers:

    _DB_PATH = '/var/local/wireguard_users.db'

    def __init__(self):
        self._con = self._get_db_connection()
        self._cur = self._con.cursor()
        self._ensure_tables()

    def get_public_key(self, uid: int) -> Optional[str]:
        for row in self._execute(
            'SELECT public_key FROM wireguard_users WHERE uid = ?',
            [uid]
        ):
            return row[0]
        return None

    def add_public_key(self, uid: int, public_key: str):
        self._execute(
            'INSERT INTO wireguard_users (uid, public_key) VALUES (?, ?) '
            'ON CONFLICT DO UPDATE SET public_key = ?',
            [uid, public_key, public_key]
        )

    def _get_db_connection(self) -> sqlite3.Connection:
        path = WireguardUsers._DB_PATH
        if not os.path.isfile(path):
            # not directly readable or writable for peers
            fd = os.open(path, os.O_CREAT, mode=0o600)
            os.close(fd)
        return sqlite3.connect(path)

    def _ensure_tables(self):
        self._execute('CREATE TABLE IF NOT EXISTS wireguard_users (uid INTEGER UNIQUE, public_key TEXT)')
        self._execute('CREATE INDEX IF NOT EXISTS uid_idx ON wireguard_users (uid)')

    def _execute(self, sql, params=[]):
        res = self._cur.execute(sql, params)
        self._con.commit()
        return res


class WireguardConfig:
    _FIELD_RE = re.compile(r'^(?P<key>[a-zA-Z]+)\s*=\s*(?P<value>.+)$')

    def __init__(self, path):
        self._path = path
        self._interface = None
        self._peers = {}
        self._parse()

    # interface
    def get_interface(self) -> Dict[str, str]:
        if self._interface is None:
            raise Exception('Config doesn\'t have interface')
        return self._interface['fields']

    # peers
    def has_peer(self, public_key: str):
        return public_key in self._peers

    def get_peer(self, public_key: str) -> Dict[str, str]:
        return dict(self._peers[public_key]['fields'])

    def iter_peers(self) -> Iterator[Dict[str, Optional[str]]]:
        for peer in self._peers.values():
            yield peer['fields']

    def set_peer_field(self, public_key: str, field: str, value: Optional[str]):
        if (peer := self._peers.get(public_key)):
            if value is None:
                if field in peer['fields']:
                    del peer['fields'][field]
            else:
                peer['fields'][field] = value

    def add_peer(self, public_key: str, fields: Dict[str, Optional[str]]):
        if public_key in self._peers:
            raise Exception('Peer already exists')
        self._peers[public_key] = {
            'type': 'Peer',
            'fields': {k: v for k, v in fields.items() if v is not None}
        }

    def delete_peer(self, public_key: str):
        if public_key in self._peers:
            del self._peers[public_key]

    # persist
    def save(self):
        block_sources = [self._interface, *self._peers.values()]
        blocks = map(self._construct_block, block_sources)
        content = '\n\n'.join(blocks) + '\n'
        with open(self._path, 'w') as f:
            f.write(content)

    # private
    def _construct_block(self, block: Dict[str, Any]) -> str:
        header = '[' + block['type'] + ']'
        fields = []
        for k, v in block['fields'].items():
            if v:
                fields.append(f'{k} = {v}')
        return '\n'.join([header, *fields])

    def _parse(self):
        with open(self._path) as f:
            for block in f.read().split('\n\n'):
                parsed_block = self._parse_block(block)
                if parsed_block['type'] == 'Interface':
                    self._interface = parsed_block
                elif parsed_block['type'] == 'Peer':
                    self._peers[parsed_block['fields']['PublicKey']] = parsed_block
                else:
                    raise Exception(f'Cannot parse block type {parsed_block["type"]}')

    def _parse_block(self, block: str) -> Dict[str, Any]:
        block_data = {
            'type': None,
            'fields': {}
        }
        for line in block.splitlines():
            if not block_data.get('type'):
                if line == '[Interface]':
                    block_data['type'] = 'Interface'
                elif line == '[Peer]':
                    block_data['type'] = 'Peer'
                else:
                    raise Exception(f'Unexpected block header: {line}')
                continue
            m = self._FIELD_RE.match(line)
            if m:
                field = m.groupdict()
                block_data['fields'][field['key']] = field['value']
            else:
                raise Exception(f'Invalid field: {line}')
        return block_data


class WireguardConfigManager:
    def __init__(self):
        self._config = WireguardConfig('/etc/wireguard/wg0.conf')
        self._wireguard_users = WireguardUsers()

    def add_peer(
        self,
        uid: int,
        public_key: str,
        endpoint: Optional[str]=None
    ) -> Dict[str, Dict[str, Any]]:
        old_public_key = self._wireguard_users.get_public_key(uid)
        if old_public_key is not None:
            self._config.delete_peer(old_public_key)
        if self._config.has_peer(public_key):
            raise Exception(f'Peer already exists for public key {public_key}')
        self._wireguard_users.add_public_key(uid, public_key)

        new_peer_psk = self._gen_psk()
        new_peer_address = self._get_available_address()

        # add new peer to own config
        self._config.add_peer(public_key, {
            'PublicKey': public_key,
            'PresharedKey': new_peer_psk,
            'AllowedIPs': str(ipaddress.IPv4Network(new_peer_address)),
            'Endpoint': endpoint,
        })
        self._config.save()

        this_interface = self._config.get_interface()
        this_interface_mask = ipaddress.IPv4Interface(this_interface['Address']).netmask
        ip_interface = ipaddress.IPv4Interface(this_interface['Address'])

        # return new peer as interface and interface as peer
        return {
            'interface': {
                'type': 'Interface',
                'fields': {
                    'Address': str(ipaddress.IPv4Interface((
                        str(new_peer_address),
                        str(this_interface_mask)
                    ))),
                }
            },
            'peer': {
                'type': 'Peer',
                'fields': {
                    'PublicKey': self._get_pubkey(),
                    'PresharedKey': new_peer_psk,
                    'AllowedIPs': str(ipaddress.IPv4Network(ip_interface.ip)),
                    # peer is expected to know how to substitute the IP/host
                    'Endpoint': f'0.0.0.0:{this_interface["ListenPort"]}',
                }
            }
        }

    def set_peer_endpoint(self, uid: int, endpoint: Optional[str]) -> Dict[str, str]:
        public_key = self._wireguard_users.get_public_key(uid)
        if public_key is None:
            raise Exception(f'Peer does not exist for user {uid}')
        peer = self._config.get_peer(public_key)
        self._config.set_peer_field(public_key, 'Endpoint', endpoint)
        self._config.save()
        return self._config.get_peer(public_key)

    def _get_available_address(self) -> ipaddress.IPv4Address:
        interface = self._config.get_interface()
        ip_interface = ipaddress.IPv4Interface(interface['Address'])
        network = ip_interface.network
        reserved = {ip_interface.ip, network.network_address}
        for peer in self._config.iter_peers():
            if 'AllowedIPs' not in peer or peer['AllowedIPs'] is None:
                raise Exception(f'Peer {peer["PublicKey"]} is missing AllowedIPs')
            for peer_network in peer['AllowedIPs'].split(', '):
                peer_network = ipaddress.IPv4Network(peer_network)
                if peer_network.subnet_of(network):
                    reserved |= set(peer_network)
        for ip in network:
            if ip not in reserved:
                return ip
        raise Exception('Address space exhausted')

    def _gen_psk(self) -> str:
        psk_proc = subprocess.run(['wg', 'genpsk'], stdout=subprocess.PIPE)
        if not psk_proc.stdout:
            raise Exception('Could not generate PSK')
        return psk_proc.stdout.decode('utf-8').rstrip('\n')

    def _get_pubkey(self) -> str:
        interface = self._config.get_interface()
        pubkey_proc = subprocess.Popen(
            ['wg', 'pubkey'],
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE
        )
        if not pubkey_proc.stdin:
            raise Exception('Could not generate public key')
        private_key = interface['PrivateKey'] + '\n'
        pubkey_proc.stdin.write(private_key.encode('utf-8'))
        pubkey_proc.stdin.close()
        if not pubkey_proc.stdout:
            raise Exception('Could not generate public key')
        return pubkey_proc.stdout.read().decode('utf-8').rstrip('\n')


class WireguardPeerServer(socketserver.UnixStreamServer):

    def __init__(self, *args, **kwargs):
        config_manager = kwargs.pop('config_manager')
        super().__init__(*args, **kwargs)
        self.config_manager: WireguardConfigManager = config_manager

    def server_bind(self):
        fd = self.socket.fileno()
        # restrict access to root before binding
        os.fchmod(fd, 0o600)
        super().server_bind()

    def server_activate(self):
        super().server_activate()
        addr = self.server_address
        if not isinstance(addr, str):
            raise Exception(f'Unexpected server_address: {addr}')
        # grant access to the wireguard_users group as well
        root_user = pwd.getpwnam('root')
        wireguard_users_group = grp.getgrnam('wireguard_users')
        os.chown(addr, root_user.pw_uid, wireguard_users_group.gr_gid)
        os.chmod(addr, 0o660)


class WireguardPeerRequestHandler(socketserver.StreamRequestHandler):

    server: WireguardPeerServer

    def setup(self, *args, **kwargs):
        self._config_manager = self.server.config_manager
        super().setup(*args, **kwargs)

    def handle(self):
        line = self.rfile.readline()
        command = json.loads(line)
        self._handle_command(command)

    def _handle_command(self, command: Dict[str, Any]):
        result: Dict[str, Any] = {
            'status': None,
            'data': None
        }
        try:
            uid = self._get_uid()
            command_name = command['command']
            if command_name == 'add_peer':
                public_key = command['data']['public_key']
                result['data'] = self._config_manager.add_peer(uid, public_key)
            elif command_name == 'set_peer_endpoint':
                endpoint = command['data']['endpoint']
                result['data'] = self._config_manager.set_peer_endpoint(uid, endpoint)
            else:
                raise Exception(f'Unknown command: {command_name}')
            result['status'] = 'ok'
        except Exception as e:
            result['status'] = 'error'
            result['data'] = ''.join(traceback.TracebackException.from_exception(e).format())
        self.wfile.write(json.dumps(result).encode('utf-8') + b'\n')

    def _get_uid(self):
        creds = self.request.getsockopt(
            socket.SOL_SOCKET,
            socket.SO_PEERCRED,
            struct.calcsize('3i')
        )
        _, uid, _ = struct.unpack('3i', creds)
        return uid


def main():
    socket_path = '/run/wireguard_peer.sock'
    with contextlib.suppress(FileNotFoundError):
        os.remove(socket_path)
    server = WireguardPeerServer(
        socket_path,
        WireguardPeerRequestHandler,
        config_manager=WireguardConfigManager()
    )
    server.serve_forever()


if __name__ == '__main__':
    main()
